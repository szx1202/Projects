# --- Versione File YAML derivata da Irriga_2p_rtc_ds.ino 
#-----------------------------------------------------------------------------
# --- V2.1 --- 
# Sostituito DHT22 con Modulo DS18B20 per gestione Temperatura Ambiente ---
# eliminato ip statico per connessione wifi causa problemi con NTP
# -----------------------------------------------------------------------------
#------------------------------ V3.0------------------------------------------
# compatibilità con dashboard HTML irriga_2p_rtc_ds-yml.html 
# implementata sincronizzazione stato switch Manutenzione tra HA e HTML
#-----------------------------------------------------------------------------

substitutions:
  device_name: "irrig_2p_rtc_ds"
  friendly_name: "Irrigatore a 2 Pompe con RTC"
  active_time_min: "5"
  sleep_time_min: "55"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

  on_boot:
    priority: 600
    then:
      - globals.set:
          id: awake_start_time_ms
          value: !lambda "return millis();"
      - text_sensor.template.publish:
          id: device_status_sensor
          state: "Booting..."

esp32:
  board: esp32dev
  framework:
    type: arduino

api:
  encryption:
    key: "eGmkiHfVBi3QJHwYh1ilu1Im0lLdwrGlmYjKOLBLWKw="
ota:
  platform: esphome
logger:
  baud_rate: 115200

i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
  id: i2c_bus

wifi:
  # ip viene assegnato da DHCP per evitare problemi con sincronizzazione ora NTP
  ssid: "LZ_24G"
  password: "*andromedA01."

mqtt:
  broker: 192.168.1.104
  client_id: "${device_name}-esphome"
  discovery: true
  will_message:
    topic: "${device_name}/status"
    payload: "offline"
    retain: true
    
  on_connect:
    then:
      - text_sensor.template.publish:
          id: device_status_sensor
          state: "Online"
      - wait_until:
          condition:
            lambda: 'return id(sntp_time).now().is_valid();'
          timeout: 30s
      - if:
          condition:
            lambda: 'return !id(sntp_time).now().is_valid();'
          then:
            - logger.log: "ATTENZIONE: Timeout NTP! L'ora non è stata sincronizzata via rete. Si utilizza l'ora dell'RTC."
          else:
            - logger.log: "Ora sincronizzata con NTP. Aggiorno tutti i sensori."
            - component.update: last_boot_time
            - component.update: dht_hub
            - component.update: umidita_terreno_1
            - component.update: umidita_terreno_2
            - component.update: durata_totale_pompa_1
            - component.update: durata_totale_pompa_2
            
# ... all'interno della tua sezione mqtt: ...
  
  on_message:
    # --- Questo blocco per il bottone rimane invariato ---
    - topic: ${device_name}/button/updsensordata/command
      then:
        - logger.log: "Richiesta di aggiornamento manuale da MQTT ricevuta."
        - button.press: update_sensors_button

    # --- INIZIO BLOCCO CORRETTO ---
    # Nota la doppia underscore in "modalita__manutenzione" nel topic
    - topic: ${device_name}/switch/modalita__manutenzione/command
      then:
        - lambda: |-
            // Converte il payload (x) in maiuscolo per essere sicuri
            std::string payload = x;
            std::transform(payload.begin(), payload.end(), payload.begin(), ::toupper);

            if (payload == "ON") {
              ESP_LOGD("main", "Comando ON ricevuto via MQTT per Modalità Manutenzione.");
              id(maintenance_mode).turn_on();
            } else if (payload == "OFF") {
              ESP_LOGD("main", "Comando OFF ricevuto via MQTT per Modalità Manutenzione.");
              id(maintenance_mode).turn_off();
            }
  # --- FINE BLOCCO CORRETTO ---
globals:
  - id: awake_start_time_ms
    type: unsigned long
    initial_value: '0'
  - id: maintenance_mode_enabled
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: pump1_start_time_ms
    type: unsigned long
    initial_value: '0'
  - id: pump2_start_time_ms
    type: unsigned long
    initial_value: '0'
  - id: pump1_total_duration_s
    type: unsigned int
    initial_value: '0'
  - id: pump2_total_duration_s
    type: unsigned int
    initial_value: '0'

deep_sleep:
  sleep_duration: ${sleep_time_min}min
  id: deep_sleep_component

interval:
  - interval: 30s
    then:
      - if:
          condition:
            and:
              - lambda: !lambda 'return !id(maintenance_mode_enabled);'
              - lambda: !lambda 'return millis() > (${active_time_min} * 60 * 1000);'
          then:
            - script.execute: check_and_sleep
            
  - interval: 1h
    then:
      - if:
          condition:
            lambda: 'return id(sntp_time).now().is_valid();'
          then:
            - script.execute: sync_rtc_with_sntp

script:
  - id: check_and_sleep
    mode: single
    then:
      - if:
          condition:
            and:
              - switch.is_off: pompa_1
              - switch.is_off: pompa_2
          then:
            - logger.log: "Condizioni soddisfatte. Invio stato 'Sleeping' e avvio deep sleep."
            - text_sensor.template.publish:
                id: device_status_sensor
                state: "Sleeping"
            - delay: 200ms 
            - deep_sleep.enter: deep_sleep_component
          else:
            - logger.log: "Sleep posticipato: una pompa è ancora attiva."
  
  - id: sync_rtc_with_sntp
    mode: single
    then:
      - logger.log: "Esecuzione script: Sincronizzazione RTC (DS1307) con SNTP..."
      - lambda: |-
          ESP_LOGD("main", "Forzando la scrittura dell'ora su DS1307...");
          id(rtc_time).write_time();

switch:
  - platform: template
    name: "Modalità Manutenzione"
    id: maintenance_mode
    icon: "mdi:wrench"
    optimistic: true  # Aggiunto per reattività interfaccia HA
    lambda: 'return id(maintenance_mode_enabled);'
    turn_on_action:
      - globals.set: {id: maintenance_mode_enabled, value: 'true'}
    turn_off_action:
      - globals.set: {id: maintenance_mode_enabled, value: 'false'}

  - platform: gpio
    name: "Pompa 1"
    id: pompa_1
    pin: GPIO25
    restore_mode: ALWAYS_OFF
    on_turn_on:
      then:
        - lambda: 'id(pump1_start_time_ms) = millis();'
    on_turn_off:
      then:
        - if:
            condition:
              lambda: 'return id(pump1_start_time_ms) > 0;'
            then:
              - lambda: |-
                  unsigned long duration = (millis() - id(pump1_start_time_ms)) / 1000;
                  id(pump1_total_duration_s) += duration;
                  id(pump1_start_time_ms) = 0;
              - component.update: durata_totale_pompa_1

  - platform: gpio
    name: "Pompa 2"
    id: pompa_2
    pin: GPIO27
    restore_mode: ALWAYS_OFF
    on_turn_on:
      then:
        - lambda: 'id(pump2_start_time_ms) = millis();'
    on_turn_off:
      then:
        - if:
            condition:
              lambda: 'return id(pump2_start_time_ms) > 0;'
            then:
              - lambda: |-
                  unsigned long duration = (millis() - id(pump2_start_time_ms)) / 1000;
                  id(pump2_total_duration_s) += duration;
                  id(pump2_start_time_ms) = 0;
              - component.update: durata_totale_pompa_2

sensor:
  - platform: dht
    id: dht_hub
    pin: GPIO13
    model: DHT22
    update_interval: 60s
    temperature:
      name: "Temperatura Aria"
    humidity:
      name: "Umidità Aria"

  - platform: adc
    pin: GPIO32
    name: "Umidità Terreno 1"
    id: umidita_terreno_1
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 0.000805664
      - calibrate_linear:
          - 1.25 -> 100.0
          - 3.0 -> 0.0
      - clamp: { min_value: 0, max_value: 100 }

  - platform: adc
    pin: GPIO35
    name: "Umidità Terreno 2"
    id: umidita_terreno_2
    update_interval: 60s
    attenuation: 12db
    filters:
      - calibrate_linear:
          - 1.25 -> 100.0
          - 2.88 -> 0.0
      - clamp: { min_value: 0, max_value: 100 }

  - platform: template
    name: "Durata Sessione Pompa 1"
    id: durata_totale_pompa_1
    lambda: 'return id(pump1_total_duration_s);'
    update_interval: 3600s
    unit_of_measurement: s
    icon: "mdi:timer"

  - platform: template
    name: "Durata Sessione Pompa 2"
    id: durata_totale_pompa_2
    lambda: 'return id(pump2_total_duration_s);'
    update_interval: 3600s
    unit_of_measurement: s
    icon: "mdi:timer"

time:
  - platform: ds1307
    id: rtc_time
    i2c_id: i2c_bus

  - platform: sntp
    id: sntp_time
    timezone: "Europe/Rome"
    servers:
      - time.google.com
      - pool.ntp.org

text_sensor:
  - platform: template
    name: "Ultimo Avvio"
    id: last_boot_time
    lambda: |-
      if (id(sntp_time).now().is_valid()) {
        return id(sntp_time).now().strftime("%Y-%m-%d %H:%M:%S");
      } else {
        return {std::string("Time Sync Pending...")};
      }
    icon: "mdi:clock-start"
    
  - platform: template
    name: "Stato Dispositivo"
    id: device_status_sensor

button:
  - platform: template
    name: "Aggiorna Sensori"
    id: update_sensors_button
    on_press:
      then:
        - logger.log: "Aggiornamento manuale dei sensori richiesto..."
        - component.update: dht_hub
        - component.update: umidita_terreno_1
        - component.update: umidita_terreno_2